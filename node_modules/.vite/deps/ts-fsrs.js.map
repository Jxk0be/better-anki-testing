{
  "version": 3,
  "sources": ["../../ts-fsrs/src/fsrs/models.ts", "../../ts-fsrs/src/fsrs/convert.ts", "../../ts-fsrs/src/fsrs/help.ts", "../../ts-fsrs/src/fsrs/strategies/learning_steps.ts", "../../ts-fsrs/src/fsrs/strategies/seed.ts", "../../ts-fsrs/src/fsrs/strategies/types.ts", "../../ts-fsrs/src/fsrs/abstract_scheduler.ts", "../../ts-fsrs/src/fsrs/alea.ts", "../../ts-fsrs/src/fsrs/constant.ts", "../../ts-fsrs/src/fsrs/default.ts", "../../ts-fsrs/src/fsrs/algorithm.ts", "../../ts-fsrs/src/fsrs/impl/basic_scheduler.ts", "../../ts-fsrs/src/fsrs/impl/long_term_scheduler.ts", "../../ts-fsrs/src/fsrs/reschedule.ts", "../../ts-fsrs/src/fsrs/fsrs.ts"],
  "sourcesContent": ["export type StateType = 'New' | 'Learning' | 'Review' | 'Relearning'\n\nexport enum State {\n  New = 0,\n  Learning = 1,\n  Review = 2,\n  Relearning = 3,\n}\n\nexport type RatingType = 'Manual' | 'Again' | 'Hard' | 'Good' | 'Easy'\n\nexport enum Rating {\n  Manual = 0,\n  Again = 1,\n  Hard = 2,\n  Good = 3,\n  Easy = 4,\n}\n\nexport type GradeType = Exclude<RatingType, 'Manual'>\nexport type Grade = Exclude<Rating, Rating.Manual>\n\nexport interface ReviewLog {\n  rating: Rating // Rating of the review (Again, Hard, Good, Easy)\n  state: State // State of the review (New, Learning, Review, Relearning)\n  due: Date // Date of the last scheduling\n  stability: number // Memory stability during the review\n  difficulty: number // Difficulty of the card during the review\n  /**\n   * @deprecated This field will be removed in version 6.0.0\n   */\n  elapsed_days: number // Number of days elapsed since the last review\n  /**\n   * @deprecated This field will be removed in version 6.0.0\n   */\n  last_elapsed_days: number // Number of days between the last two reviews\n  scheduled_days: number // Number of days until the next review\n  learning_steps: number // Keeps track of the current step during the (re)learning stages\n  review: Date // Date of the review\n}\n\nexport type RecordLogItem = {\n  card: Card\n  log: ReviewLog\n}\nexport type RecordLog = {\n  [key in Grade]: RecordLogItem\n}\n\nexport interface Card {\n  due: Date // Due date\n  stability: number // Stability\n  difficulty: number // Difficulty level\n  /**\n   * @deprecated This field will be removed in version 6.0.0\n   */\n  elapsed_days: number // Number of days elapsed\n  scheduled_days: number // Number of days scheduled\n  learning_steps: number // Keeps track of the current step during the (re)learning stages\n  reps: number // Repetition count\n  lapses: number // Number of lapses or mistakes\n  state: State // Card's state (New, Learning, Review, Relearning)\n  last_review?: Date // Date of the last review (optional)\n}\n\nexport interface CardInput extends Omit<Card, 'state' | 'due' | 'last_review'> {\n  state: StateType | State // Card's state (New, Learning, Review, Relearning)\n  due: DateInput // Due date\n  last_review?: DateInput | null // Date of the last review (optional)\n}\n\nexport type DateInput = Date | number | string\nexport type TimeUnit = 'm' | 'h' | 'd'\nexport type StepUnit = `${number}${TimeUnit}`\n/**\n * (re)Learning steps:\n * [1m, 10m]\n * step1:again=1m hard=6m good=10m\n * step2(good): again=1m hard=10m\n *\n * [5m]\n * step1:again=5m hard=8m\n * step2(good): again=5m\n * step2(hard): again=5m hard=7.5m\n *\n * []\n * step: Managed by FSRS\n *\n */\nexport type Steps = StepUnit[] | readonly StepUnit[]\n\nexport interface ReviewLogInput\n  extends Omit<ReviewLog, 'rating' | 'state' | 'due' | 'review'> {\n  rating: RatingType | Rating // Rating of the review (Again, Hard, Good, Easy)\n  state: StateType | State // Card's state (New, Learning, Review, Relearning)\n  due: DateInput // Due date\n  review: DateInput // Date of the last review\n}\n\nexport interface FSRSParameters {\n  request_retention: number\n  maximum_interval: number\n  w: number[] | readonly number[]\n  enable_fuzz: boolean\n  /**\n   * When enable_short_term = false, the (re)learning steps are not applied.\n   */\n  enable_short_term: boolean\n  learning_steps: Steps\n  relearning_steps: Steps\n}\n\nexport interface FSRSReview {\n  /**\n   * 0-4: Manual, Again, Hard, Good, Easy\n   * = revlog.rating\n   */\n  rating: Rating\n  /**\n   * The number of days that passed\n   * = revlog.elapsed_days\n   * = round(revlog[-1].review - revlog[-2].review)\n   */\n  delta_t: number\n}\n\nexport type FSRSHistory = Partial<\n  Omit<ReviewLog, 'rating' | 'review' | 'elapsed_days'>\n> &\n  (\n    | {\n        rating: Grade\n        review: DateInput | Date\n      }\n    | {\n        rating: Rating.Manual\n        due: DateInput | Date\n        state: State\n        review: DateInput | Date\n      }\n  )\n\nexport interface FSRSState {\n  stability: number\n  difficulty: number\n}\n", "import {\n  type Card,\n  type CardInput,\n  Rating,\n  type ReviewLog,\n  type ReviewLogInput,\n  State,\n} from './models'\n\nexport class TypeConvert {\n  static card<T extends Card | CardInput>(card: T): Card {\n    return {\n      ...card,\n      state: TypeConvert.state(card.state),\n      due: TypeConvert.time(card.due),\n      last_review: card.last_review\n        ? TypeConvert.time(card.last_review)\n        : undefined,\n    } as Card\n  }\n  static rating(value: unknown): Rating {\n    if (typeof value === 'string') {\n      const firstLetter = value.charAt(0).toUpperCase()\n      const restOfString = value.slice(1).toLowerCase()\n      const ret = Rating[`${firstLetter}${restOfString}` as keyof typeof Rating]\n      if (ret === undefined) {\n        throw new Error(`Invalid rating:[${value}]`)\n      }\n      return ret\n    } else if (typeof value === 'number') {\n      return value as Rating\n    }\n    throw new Error(`Invalid rating:[${value}]`)\n  }\n  static state(value: unknown): State {\n    if (typeof value === 'string') {\n      const firstLetter = value.charAt(0).toUpperCase()\n      const restOfString = value.slice(1).toLowerCase()\n      const ret = State[`${firstLetter}${restOfString}` as keyof typeof State]\n      if (ret === undefined) {\n        throw new Error(`Invalid state:[${value}]`)\n      }\n      return ret\n    } else if (typeof value === 'number') {\n      return value as State\n    }\n    throw new Error(`Invalid state:[${value}]`)\n  }\n  static time(value: unknown): Date {\n    const date = new Date(value as string)\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      !Number.isNaN(Date.parse(value as unknown as string) || +date)\n    ) {\n      return date\n    } else if (typeof value === 'string') {\n      const timestamp = Date.parse(value)\n      if (!Number.isNaN(timestamp)) {\n        return new Date(timestamp)\n      } else {\n        throw new Error(`Invalid date:[${value}]`)\n      }\n    } else if (typeof value === 'number') {\n      return new Date(value)\n    }\n    throw new Error(`Invalid date:[${value}]`)\n  }\n  static review_log(log: ReviewLogInput | ReviewLog): ReviewLog {\n    return {\n      ...log,\n      due: TypeConvert.time(log.due),\n      rating: TypeConvert.rating(log.rating),\n      state: TypeConvert.state(log.state),\n      review: TypeConvert.time(log.review),\n    } satisfies ReviewLog\n  }\n}\n", "import { TypeConvert } from './convert'\nimport type { DateInput, Grade } from './models'\nimport { Rating, type State } from './models'\nimport type { int, unit } from './types'\n\ndeclare global {\n  export interface Date {\n    /**\n     * @deprecated This method will be removed in version 6.0.0.\n     *\n     */\n    scheduler(t: int, isDay?: boolean): Date\n    /**\n     * @deprecated This method will be removed in version 6.0.0.\n     *\n     */\n    diff(pre: Date, unit: unit): int\n    /**\n     * @deprecated This method will be removed in version 6.0.0.\n     *\n     */\n    format(): string\n    /**\n     * @deprecated This method will be removed in version 6.0.0.\n     *\n     */\n    dueFormat(last_review: Date, unit?: boolean, timeUnit?: string[]): string\n  }\n}\n\n/* istanbul ignore next */\nDate.prototype.scheduler = function (t: int, isDay?: boolean): Date {\n  return date_scheduler(this, t, isDay)\n}\n\n/**\n * 当前时间与之前的时间差值\n * @param pre 比当前时间还要之前\n * @param unit 单位: days | minutes\n */\n/* istanbul ignore next */\nDate.prototype.diff = function (pre: Date, unit: unit): int {\n  return date_diff(this, pre, unit) as int\n}\n\n/* istanbul ignore next */\nDate.prototype.format = function (): string {\n  return formatDate(this)\n}\n\n/* istanbul ignore next */\nDate.prototype.dueFormat = function (\n  last_review: Date,\n  unit?: boolean,\n  timeUnit?: string[]\n) {\n  return show_diff_message(this, last_review, unit, timeUnit)\n}\n\n/**\n * 计算日期和时间的偏移，并返回一个新的日期对象。\n * @param now 当前日期和时间\n * @param t 时间偏移量，当 isDay 为 true 时表示天数，为 false 时表示分钟\n * @param isDay （可选）是否按天数单位进行偏移，默认为 false，表示按分钟单位计算偏移\n * @returns 偏移后的日期和时间对象\n */\nexport function date_scheduler(\n  now: DateInput,\n  t: number,\n  isDay?: boolean\n): Date {\n  return new Date(\n    isDay\n      ? TypeConvert.time(now).getTime() + t * 24 * 60 * 60 * 1000\n      : TypeConvert.time(now).getTime() + t * 60 * 1000\n  )\n}\n\nexport function date_diff(now: DateInput, pre: DateInput, unit: unit): number {\n  if (!now || !pre) {\n    throw new Error('Invalid date')\n  }\n  const diff = TypeConvert.time(now).getTime() - TypeConvert.time(pre).getTime()\n  let r = 0\n  switch (unit) {\n    case 'days':\n      r = Math.floor(diff / (24 * 60 * 60 * 1000))\n      break\n    case 'minutes':\n      r = Math.floor(diff / (60 * 1000))\n      break\n  }\n  return r\n}\n\nexport function formatDate(dateInput: DateInput): string {\n  const date = TypeConvert.time(dateInput)\n  const year: number = date.getFullYear()\n  const month: number = date.getMonth() + 1\n  const day: number = date.getDate()\n  const hours: number = date.getHours()\n  const minutes: number = date.getMinutes()\n  const seconds: number = date.getSeconds()\n\n  return `${year}-${padZero(month)}-${padZero(day)} ${padZero(hours)}:${padZero(\n    minutes\n  )}:${padZero(seconds)}`\n}\n\nfunction padZero(num: number): string {\n  return num < 10 ? `0${num}` : `${num}`\n}\n\nconst TIMEUNIT = [60, 60, 24, 31, 12]\nconst TIMEUNITFORMAT = ['second', 'min', 'hour', 'day', 'month', 'year']\n\nexport function show_diff_message(\n  due: DateInput,\n  last_review: DateInput,\n  unit?: boolean,\n  timeUnit: string[] = TIMEUNITFORMAT\n): string {\n  due = TypeConvert.time(due)\n  last_review = TypeConvert.time(last_review)\n  if (timeUnit.length !== TIMEUNITFORMAT.length) {\n    timeUnit = TIMEUNITFORMAT\n  }\n  let diff = due.getTime() - last_review.getTime()\n  let i = 0\n  diff /= 1000\n  for (i = 0; i < TIMEUNIT.length; i++) {\n    if (diff < TIMEUNIT[i]) {\n      break\n    } else {\n      diff /= TIMEUNIT[i]\n    }\n  }\n  return `${Math.floor(diff)}${unit ? timeUnit[i] : ''}`\n}\n\n/* istanbul ignore next */\n/**\n *\n * @deprecated Use TypeConvert.time instead\n * @deprecated This function will be removed in version 6.0.0.\n */\nexport function fixDate(value: unknown) {\n  return TypeConvert.time(value)\n}\n\n/* istanbul ignore next */\n/**\n * @deprecated Use TypeConvert.state instead\n * @deprecated This function will be removed in version 6.0.0.\n */\nexport function fixState(value: unknown): State {\n  return TypeConvert.state(value)\n}\n\n/* istanbul ignore next */\n/**\n * @deprecated Use TypeConvert.rating instead\n * @deprecated This function will be removed in version 6.0.0.\n */\nexport function fixRating(value: unknown): Rating {\n  return TypeConvert.rating(value)\n}\n\nexport const Grades: Readonly<Grade[]> = Object.freeze([\n  Rating.Again,\n  Rating.Hard,\n  Rating.Good,\n  Rating.Easy,\n])\n\nconst FUZZ_RANGES = [\n  {\n    start: 2.5,\n    end: 7.0,\n    factor: 0.15,\n  },\n  {\n    start: 7.0,\n    end: 20.0,\n    factor: 0.1,\n  },\n  {\n    start: 20.0,\n    end: Infinity,\n    factor: 0.05,\n  },\n] as const\n\nexport function get_fuzz_range(\n  interval: number,\n  elapsed_days: number,\n  maximum_interval: number\n) {\n  let delta = 1.0\n  for (const range of FUZZ_RANGES) {\n    delta +=\n      range.factor * Math.max(Math.min(interval, range.end) - range.start, 0.0)\n  }\n  interval = Math.min(interval, maximum_interval)\n  let min_ivl = Math.max(2, Math.round(interval - delta))\n  const max_ivl = Math.min(Math.round(interval + delta), maximum_interval)\n  if (interval > elapsed_days) {\n    min_ivl = Math.max(min_ivl, elapsed_days + 1)\n  }\n  min_ivl = Math.min(min_ivl, max_ivl)\n  return { min_ivl, max_ivl }\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function dateDiffInDays(last: Date, cur: Date) {\n  // Discard the time and time-zone information.\n  const utc1 = Date.UTC(\n    last.getUTCFullYear(),\n    last.getUTCMonth(),\n    last.getUTCDate()\n  )\n  const utc2 = Date.UTC(\n    cur.getUTCFullYear(),\n    cur.getUTCMonth(),\n    cur.getUTCDate()\n  )\n\n  return Math.floor((utc2 - utc1) / 86400000 /** 1000 * 60 * 60 * 24*/)\n}\n", "import {\n  type FSRSParameters,\n  Rating,\n  State,\n  type StepUnit,\n  type TimeUnit,\n} from '../models'\nimport type { TLearningStepsStrategy } from './types'\n\nexport const ConvertStepUnitToMinutes = (step: StepUnit): number => {\n  const unit = step.slice(-1) as TimeUnit\n  const value = parseInt(step.slice(0, -1), 10)\n  if (Number.isNaN(value) || !Number.isFinite(value) || value < 0) {\n    throw new Error(`Invalid step value: ${step}`)\n  }\n  switch (unit) {\n    case 'm':\n      return value\n    case 'h':\n      return value * 60\n    case 'd':\n      return value * 1440\n    default:\n      throw new Error(`Invalid step unit: ${step}, expected m/h/d`)\n  }\n}\n\nexport const BasicLearningStepsStrategy: TLearningStepsStrategy = (\n  params: FSRSParameters,\n  state: State,\n  cur_step: number\n) => {\n  const learning_steps =\n    state === State.Relearning || state === State.Review\n      ? params.relearning_steps\n      : params.learning_steps\n  const steps_length = learning_steps.length\n  // steps_length === 0 ,return empty object\n  if (steps_length === 0 || cur_step >= steps_length) return {}\n\n  // steps_length > 0\n  const firstStep = learning_steps[0]\n\n  const toMinutes = ConvertStepUnitToMinutes\n\n  const getAgainInterval = (): number => {\n    return toMinutes(firstStep)\n  }\n\n  const getHardInterval = (): number => {\n    // steps_length > 0,return firstStep*1.5\n    if (steps_length === 1) return Math.round(toMinutes(firstStep) * 1.5)\n    // steps_length > 1,return (firstStep+nextStep)/2\n    const nextStep = learning_steps[1]\n    return Math.round((toMinutes(firstStep) + toMinutes(nextStep)) / 2)\n  }\n\n  const getStepInfo = (index: number) => {\n    if (index < 0 || index >= steps_length) {\n      return null\n    } else {\n      return learning_steps[index]\n    }\n  }\n\n  const getGoodMinutes = (step: StepUnit): number | null => {\n    return toMinutes(step)\n  }\n\n  const result: ReturnType<TLearningStepsStrategy> = {}\n  const step_info = getStepInfo(Math.max(0, cur_step))\n  // review -> again\n  // new, learning, relearning -> again,hard,good(if next step exists)\n  if (state === State.Review) {\n    // review\n    result[Rating.Again] = {\n      scheduled_minutes: toMinutes(step_info!),\n      next_step: 0,\n    }\n    return result\n  } else {\n    // new,learning, relearning\n    result[Rating.Again] = {\n      scheduled_minutes: getAgainInterval(),\n      next_step: 0,\n    }\n\n    result[Rating.Hard] = {\n      scheduled_minutes: getHardInterval(),\n      next_step: cur_step,\n    }\n    const next_info = getStepInfo(cur_step + 1)\n    if (next_info) {\n      const nextMin = getGoodMinutes(next_info)\n\n      if (nextMin) {\n        result[Rating.Good] = {\n          scheduled_minutes: Math.round(nextMin),\n          next_step: cur_step + 1,\n        }\n      }\n    }\n  }\n  return result\n}\n", "import type { AbstractScheduler } from '../abstract_scheduler'\nimport type { TSeedStrategy } from './types'\n\nexport function DefaultInitSeedStrategy(this: AbstractScheduler): string {\n  const time = this.review_time.getTime()\n  const reps = this.current.reps\n  const mul = this.current.difficulty * this.current.stability\n  return `${time}_${reps}_${mul}`\n}\n\n/**\n * Generates a seed strategy function for card IDs.\n *\n * @param card_id_field - The field name of the card ID in the current object.\n * @returns A function that generates a seed based on the card ID and repetitions.\n *\n * @remarks\n * The returned function uses the `card_id_field` to retrieve the card ID from the current object.\n * It then adds the number of repetitions (`reps`) to the card ID to generate the seed.\n *\n * @example\n * ```typescript\n * const seedStrategy = GenCardIdSeedStrategy('card_id');\n * const f = fsrs().useStrategy(StrategyMode.SEED, seedStrategy)\n * const card = createEmptyCard<Card & { card_id: number }>()\n * card.card_id = 555\n * const record = f.repeat(card, new Date())\n * ```\n */\nexport function GenSeedStrategyWithCardId(\n  card_id_field: string | number\n): TSeedStrategy {\n  return function (this: AbstractScheduler): string {\n    // https://github.com/open-spaced-repetition/ts-fsrs/issues/131#issuecomment-2408426225\n    const card_id = Reflect.get(this.current, card_id_field) ?? 0\n    const reps = this.current.reps\n    // ex1\n    // card_id:string + reps:number = 'e2ecb1f7-8d15-420b-bec4-c7212ad2e5dc' + 4\n    // = 'e2ecb1f7-8d15-420b-bec4-c7212ad2e5dc4'\n\n    // ex2\n    // card_id:number + reps:number = 1732452519198 + 4\n    // = '17324525191984'\n    return String(card_id + reps || 0)\n  }\n}\n", "import type { AbstractScheduler } from '../abstract_scheduler'\nimport type { FSRSAlgorithm } from '../algorithm'\nimport type {\n  Card,\n  CardInput,\n  DateInput,\n  FSRSParameters,\n  Grade,\n  State,\n} from '../models'\nimport type { IScheduler } from '../types'\n\nexport enum StrategyMode {\n  SCHEDULER = 'Scheduler',\n  LEARNING_STEPS = 'LearningSteps',\n  SEED = 'Seed',\n}\n\nexport type TSeedStrategy = (this: AbstractScheduler) => string\nexport type TSchedulerStrategy<T extends CardInput | Card = CardInput | Card> =\n  new (\n    card: T,\n    now: DateInput,\n    algorithm: FSRSAlgorithm,\n    strategies: Map<StrategyMode, TStrategyHandler>\n  ) => IScheduler\n\n/**\n * When enable_short_term = false, the learning steps strategy will not take effect.\n */\nexport type TLearningStepsStrategy = (\n  params: FSRSParameters,\n  state: State,\n  cur_step: number\n) => {\n  [K in Grade]?: { scheduled_minutes: number; next_step: number }\n}\n\ntype StrategyMap = {\n  [StrategyMode.SCHEDULER]: TSchedulerStrategy\n  [StrategyMode.SEED]: TSeedStrategy\n  [StrategyMode.LEARNING_STEPS]: TLearningStepsStrategy\n}\n\nexport type TStrategyHandler<E = StrategyMode> = E extends StrategyMode\n  ? StrategyMap[E]\n  : never\n", "import type { FSRSAlgorithm } from './algorithm'\nimport { TypeConvert } from './convert'\nimport { dateDiffInDays, Grades } from './help'\nimport {\n  type Card,\n  type CardInput,\n  type DateInput,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  type ReviewLog,\n  State,\n} from './models'\nimport { DefaultInitSeedStrategy } from './strategies'\nimport {\n  StrategyMode,\n  type TSeedStrategy,\n  type TStrategyHandler,\n} from './strategies/types'\nimport type { IPreview, IScheduler } from './types'\n\nexport abstract class AbstractScheduler implements IScheduler {\n  protected last: Card\n  protected current: Card\n  protected review_time: Date\n  protected next: Map<Grade, RecordLogItem> = new Map()\n  protected algorithm: FSRSAlgorithm\n  protected strategies: Map<StrategyMode, TStrategyHandler> | undefined\n  protected elapsed_days: number = 0 // init\n\n  constructor(\n    card: CardInput | Card,\n    now: DateInput,\n    algorithm: FSRSAlgorithm,\n    strategies?: Map<StrategyMode, TStrategyHandler>\n  ) {\n    this.algorithm = algorithm\n    this.last = TypeConvert.card(card)\n    this.current = TypeConvert.card(card)\n    this.review_time = TypeConvert.time(now)\n    this.strategies = strategies\n    this.init()\n  }\n\n  protected checkGrade(grade: Grade): void {\n    if (!Number.isFinite(grade) || grade < 0 || grade > 4) {\n      throw new Error(`Invalid grade \"${grade}\",expected 1-4`)\n    }\n  }\n\n  private init() {\n    const { state, last_review } = this.current\n    let interval = 0 // card.state === State.New => 0\n    if (state !== State.New && last_review) {\n      interval = dateDiffInDays(last_review, this.review_time)\n    }\n    this.current.last_review = this.review_time\n    this.elapsed_days = interval\n    // pending removal in v6.0.0\n    this.current.elapsed_days = interval\n    this.current.reps += 1\n\n    // init seed strategy\n    let seed_strategy = DefaultInitSeedStrategy\n    if (this.strategies) {\n      const custom_strategy = this.strategies.get(StrategyMode.SEED)\n      if (custom_strategy) {\n        seed_strategy = custom_strategy as TSeedStrategy\n      }\n    }\n    this.algorithm.seed = (<TSeedStrategy>seed_strategy).call(this)\n  }\n\n  public preview(): IPreview {\n    return {\n      [Rating.Again]: this.review(Rating.Again),\n      [Rating.Hard]: this.review(Rating.Hard),\n      [Rating.Good]: this.review(Rating.Good),\n      [Rating.Easy]: this.review(Rating.Easy),\n      [Symbol.iterator]: this.previewIterator.bind(this),\n    } satisfies IPreview\n  }\n\n  private *previewIterator(): IterableIterator<RecordLogItem> {\n    for (const grade of Grades) {\n      yield this.review(grade)\n    }\n  }\n\n  public review(grade: Grade): RecordLogItem {\n    const { state } = this.last\n    let item: RecordLogItem | undefined\n    this.checkGrade(grade)\n    switch (state) {\n      case State.New:\n        item = this.newState(grade)\n        break\n      case State.Learning:\n      case State.Relearning:\n        item = this.learningState(grade)\n        break\n      case State.Review:\n        item = this.reviewState(grade)\n        break\n    }\n    return item\n  }\n\n  protected abstract newState(grade: Grade): RecordLogItem\n\n  protected abstract learningState(grade: Grade): RecordLogItem\n\n  protected abstract reviewState(grade: Grade): RecordLogItem\n\n  protected buildLog(rating: Grade): ReviewLog {\n    const { last_review, due, elapsed_days } = this.last\n\n    return {\n      rating: rating,\n      state: this.current.state,\n      due: last_review || due,\n      stability: this.current.stability,\n      difficulty: this.current.difficulty,\n      elapsed_days: this.elapsed_days,\n      last_elapsed_days: elapsed_days,\n      scheduled_days: this.current.scheduled_days,\n      learning_steps: this.current.learning_steps,\n      review: this.review_time,\n    } satisfies ReviewLog\n  }\n}\n", "// https://github.com/davidbau/seedrandom/blob/released/lib/alea.js\n// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype State = {\n  c: number\n  s0: number\n  s1: number\n  s2: number\n}\n\nclass Alea {\n  private c: number\n  private s0: number\n  private s1: number\n  private s2: number\n\n  constructor(seed?: number | string) {\n    const mash = Mash()\n    this.c = 1\n    this.s0 = mash(' ')\n    this.s1 = mash(' ')\n    this.s2 = mash(' ')\n    if (seed == null) seed = Date.now()\n    this.s0 -= mash(seed)\n    if (this.s0 < 0) this.s0 += 1\n    this.s1 -= mash(seed)\n    if (this.s1 < 0) this.s1 += 1\n    this.s2 -= mash(seed)\n    if (this.s2 < 0) this.s2 += 1\n  }\n\n  next(): number {\n    const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10 // 2^-32\n    this.s0 = this.s1\n    this.s1 = this.s2\n    this.c = t | 0\n    this.s2 = t - this.c\n    return this.s2\n  }\n\n  set state(state: State) {\n    this.c = state.c\n    this.s0 = state.s0\n    this.s1 = state.s1\n    this.s2 = state.s2\n  }\n\n  get state(): State {\n    return {\n      c: this.c,\n      s0: this.s0,\n      s1: this.s1,\n      s2: this.s2,\n    }\n  }\n}\n\nfunction Mash() {\n  let n = 0xefc8249d\n  return function mash(data: string | number): number {\n    data = String(data)\n    for (let i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i)\n      let h = 0.02519603282416938 * n\n      n = h >>> 0\n      h -= n\n      h *= n\n      n = h >>> 0\n      h -= n\n      n += h * 0x100000000 // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10 // 2^-32\n  }\n}\n\nfunction alea(seed?: number | string) {\n  const xg = new Alea(seed)\n  const prng = () => xg.next()\n\n  prng.int32 = () => (xg.next() * 0x100000000) | 0\n  prng.double = () =>\n    prng() + ((prng() * 0x200000) | 0) * 1.1102230246251565e-16 // 2^-53\n  prng.state = () => xg.state\n  prng.importState = (state: State) => {\n    xg.state = state\n    return prng\n  }\n  return prng\n}\n\nexport { alea }\n", "import { version } from '../../package.json'\nimport type { StepUnit } from './models'\n\nexport const default_request_retention = 0.9\nexport const default_maximum_interval = 36500\nexport const default_enable_fuzz = false\nexport const default_enable_short_term = true\nexport const default_learning_steps: readonly StepUnit[] = Object.freeze([\n  '1m',\n  '10m',\n]) // New->Learning,Learning->Learning\n\nexport const default_relearning_steps: readonly StepUnit[] = Object.freeze([\n  '10m',\n]) // Relearning->Relearning\n\nexport const FSRSVersion: string = `v${version} using FSRS-6.0`\n\nexport const S_MIN = 0.001\nexport const S_MAX = 36500.0\nexport const INIT_S_MAX = 100.0\nexport const FSRS5_DEFAULT_DECAY = 0.5\nexport const FSRS6_DEFAULT_DECAY = 0.1542\nexport const default_w = Object.freeze([\n  0.212,\n  1.2931,\n  2.3065,\n  8.2956,\n  6.4133,\n  0.8334,\n  3.0194,\n  0.001,\n  1.8722,\n  0.1666,\n  0.796,\n  1.4835,\n  0.0614,\n  0.2629,\n  1.6483,\n  0.6014,\n  1.8729,\n  0.5425,\n  0.0912,\n  0.0658,\n  FSRS6_DEFAULT_DECAY,\n]) satisfies readonly number[]\n\nexport const W17_W18_Ceiling = 2.0\nexport const CLAMP_PARAMETERS = (\n  w17_w18_ceiling: number,\n  enable_short_term: boolean = default_enable_short_term\n) => [\n  [S_MIN, INIT_S_MAX] /** initial stability (Again) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Hard) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Good) */,\n  [S_MIN, INIT_S_MAX] /** initial stability (Easy) */,\n  [1.0, 10.0] /** initial difficulty (Good) */,\n  [0.001, 4.0] /** initial difficulty (multiplier) */,\n  [0.001, 4.0] /** difficulty (multiplier) */,\n  [0.001, 0.75] /** difficulty (multiplier) */,\n  [0.0, 4.5] /** stability (exponent) */,\n  [0.0, 0.8] /** stability (negative power) */,\n  [0.001, 3.5] /** stability (exponent) */,\n  [0.001, 5.0] /** fail stability (multiplier) */,\n  [0.001, 0.25] /** fail stability (negative power) */,\n  [0.001, 0.9] /** fail stability (power) */,\n  [0.0, 4.0] /** fail stability (exponent) */,\n  [0.0, 1.0] /** stability (multiplier for Hard) */,\n  [1.0, 6.0] /** stability (multiplier for Easy) */,\n  [0.0, w17_w18_ceiling] /** short-term stability (exponent) */,\n  [0.0, w17_w18_ceiling] /** short-term stability (exponent) */,\n  [\n    enable_short_term ? 0.01 : 0.0,\n    0.8,\n  ] /** short-term last-stability (exponent) */,\n  [0.1, 0.8] /** decay */,\n]\n", "import {\n  CLAMP_PARAMETERS,\n  default_enable_fuzz,\n  default_enable_short_term,\n  default_learning_steps,\n  default_maximum_interval,\n  default_relearning_steps,\n  default_request_retention,\n  default_w,\n  FSRS5_DEFAULT_DECAY,\n  W17_W18_Ceiling,\n} from './constant'\nimport { TypeConvert } from './convert'\nimport { clamp } from './help'\nimport { type Card, type DateInput, type FSRSParameters, State } from './models'\n\nexport const clipParameters = (\n  parameters: number[],\n  numRelearningSteps: number,\n  enableShortTerm: boolean = default_enable_short_term\n) => {\n  let w17_w18_ceiling = W17_W18_Ceiling\n  if (Math.max(0, numRelearningSteps) > 1) {\n    // PLS = w11 * D ^ -w12 * [(S + 1) ^ w13 - 1] * e ^ (w14 * (1 - R))\n    // PLS * e ^ (num_relearning_steps * w17 * w18) should be <= S\n    // Given D = 1, R = 0.7, S = 1, PLS is equal to w11 * (2 ^ w13 - 1) * e ^ (w14 * 0.3)\n    // So num_relearning_steps * w17 * w18 + ln(w11) + ln(2 ^ w13 - 1) + w14 * 0.3 should be <= ln(1)\n    // => num_relearning_steps * w17 * w18 <= - ln(w11) - ln(2 ^ w13 - 1) - w14 * 0.3\n    // => w17 * w18 <= -[ln(w11) + ln(2 ^ w13 - 1) + w14 * 0.3] / num_relearning_steps\n    const value =\n      -(\n        Math.log(parameters[11]) +\n        Math.log(Math.pow(2.0, parameters[13]) - 1.0) +\n        parameters[14] * 0.3\n      ) / numRelearningSteps\n\n    w17_w18_ceiling = clamp(+value.toFixed(8), 0.01, 2.0)\n  }\n  const clip = CLAMP_PARAMETERS(w17_w18_ceiling, enableShortTerm).slice(\n    0,\n    parameters.length\n  )\n  return clip.map(([min, max], index) =>\n    clamp(parameters[index] || 0, min, max)\n  )\n}\n\n/**\n * @returns The input if the parameters are valid, throws if they are invalid\n * @example\n * try {\n *   generatorParameters({\n *     w: checkParameters([0.40255])\n *   });\n * } catch (e: any) {\n *   alert(e);\n * }\n */\nexport const checkParameters = (parameters: number[] | readonly number[]) => {\n  const invalid = parameters.find(\n    (param) => !Number.isFinite(param) && !Number.isNaN(param)\n  )\n  if (invalid !== undefined) {\n    throw Error(`Non-finite or NaN value in parameters ${parameters}`)\n  } else if (![17, 19, 21].includes(parameters.length)) {\n    throw Error(\n      `Invalid parameter length: ${parameters.length}. Must be 17, 19 or 21 for FSRSv4, 5 and 6 respectively.`\n    )\n  }\n  return parameters\n}\n\nexport const migrateParameters = (\n  parameters?: number[] | readonly number[],\n  numRelearningSteps: number = 0,\n  enableShortTerm: boolean = default_enable_short_term\n) => {\n  if (parameters === undefined) {\n    return [...default_w]\n  }\n  switch (parameters.length) {\n    case 21:\n      return clipParameters(\n        Array.from(parameters),\n        numRelearningSteps,\n        enableShortTerm\n      )\n    case 19:\n      console.debug('[FSRS-6]auto fill w from 19 to 21 length')\n      return clipParameters(\n        Array.from(parameters),\n        numRelearningSteps,\n        enableShortTerm\n      ).concat([0.0, FSRS5_DEFAULT_DECAY])\n    case 17: {\n      const w = clipParameters(\n        Array.from(parameters),\n        numRelearningSteps,\n        enableShortTerm\n      )\n      w[4] = +(w[5] * 2.0 + w[4]).toFixed(8)\n      w[5] = +(Math.log(w[5] * 3.0 + 1.0) / 3.0).toFixed(8)\n      w[6] = +(w[6] + 0.5).toFixed(8)\n      console.debug('[FSRS-6]auto fill w from 17 to 21 length')\n      return w.concat([0.0, 0.0, 0.0, FSRS5_DEFAULT_DECAY])\n    }\n    default:\n      // To throw use \"checkParameters\"\n      // ref: https://github.com/open-spaced-repetition/ts-fsrs/pull/174#discussion_r2070436201\n      console.warn('[FSRS]Invalid parameters length, using default parameters')\n      return [...default_w]\n  }\n}\n\nexport const generatorParameters = (\n  props?: Partial<FSRSParameters>\n): FSRSParameters => {\n  const learning_steps = Array.isArray(props?.learning_steps)\n    ? props!.learning_steps\n    : default_learning_steps\n  const relearning_steps = Array.isArray(props?.relearning_steps)\n    ? props!.relearning_steps\n    : default_relearning_steps\n  const enable_short_term =\n    props?.enable_short_term ?? default_enable_short_term\n  const w = migrateParameters(\n    props?.w,\n    relearning_steps.length,\n    enable_short_term\n  )\n\n  return {\n    request_retention: props?.request_retention || default_request_retention,\n    maximum_interval: props?.maximum_interval || default_maximum_interval,\n    w: w,\n    enable_fuzz: props?.enable_fuzz ?? default_enable_fuzz,\n    enable_short_term: enable_short_term,\n    learning_steps: learning_steps,\n    relearning_steps: relearning_steps,\n  } satisfies FSRSParameters\n}\n\n/**\n * Create an empty card\n * @param now Current time\n * @param afterHandler Convert the result to another type. (Optional)\n * @example\n * ```typescript\n * const card: Card = createEmptyCard(new Date());\n * ```\n * @example\n * ```typescript\n * interface CardUnChecked\n *   extends Omit<Card, \"due\" | \"last_review\" | \"state\"> {\n *   cid: string;\n *   due: Date | number;\n *   last_review: Date | null | number;\n *   state: StateType;\n * }\n *\n * function cardAfterHandler(card: Card) {\n *      return {\n *       ...card,\n *       cid: \"test001\",\n *       state: State[card.state],\n *       last_review: card.last_review ?? null,\n *     } as CardUnChecked;\n * }\n *\n * const card: CardUnChecked = createEmptyCard(new Date(), cardAfterHandler);\n * ```\n */\nexport function createEmptyCard<R = Card>(\n  now?: DateInput,\n  afterHandler?: (card: Card) => R\n): R {\n  const emptyCard: Card = {\n    due: now ? TypeConvert.time(now) : new Date(),\n    stability: 0,\n    difficulty: 0,\n    elapsed_days: 0,\n    scheduled_days: 0,\n    reps: 0,\n    lapses: 0,\n    learning_steps: 0,\n    state: State.New,\n    last_review: undefined,\n  }\n  if (afterHandler && typeof afterHandler === 'function') {\n    return afterHandler(emptyCard)\n  } else {\n    return emptyCard as R\n  }\n}\n", "import { alea } from './alea'\nimport { S_MIN } from './constant'\nimport { generatorParameters, migrateParameters } from './default'\nimport { clamp, get_fuzz_range } from './help'\nimport {\n  type FSRSParameters,\n  type FSRSState,\n  type Grade,\n  Rating,\n} from './models'\nimport type { int } from './types'\n/**\n * $$\\text{decay} = -w_{20}$$\n *\n * $$\\text{factor} = e^{\\frac{\\ln 0.9}{\\text{decay}}} - 1$$\n */\nexport const computeDecayFactor = (\n  decayOrParams: number | number[] | readonly number[]\n) => {\n  const decay =\n    typeof decayOrParams === 'number' ? -decayOrParams : -decayOrParams[20]\n  const factor = Math.exp(Math.pow(decay, -1) * Math.log(0.9)) - 1.0\n  return { decay, factor: +factor.toFixed(8) }\n}\n\n/**\n * The formula used is :\n * $$R(t,S) = (1 + \\text{FACTOR} \\times \\frac{t}{9 \\cdot S})^{\\text{DECAY}}$$\n * @param {number} decay - The decay factor, decay should be greater than or equal to 0.1 and less than or equal to 0.8.\n * @param {number} elapsed_days t days since the last review\n * @param {number} stability Stability (interval when R=90%)\n * @return {number} r Retrievability (probability of recall)\n */\nexport function forgetting_curve(\n  decay: number,\n  elapsed_days: number,\n  stability: number\n): number\nexport function forgetting_curve(\n  parameters: number[] | readonly number[],\n  elapsed_days: number,\n  stability: number\n): number\nexport function forgetting_curve(\n  decayOrParams: number | number[] | readonly number[],\n  elapsed_days: number,\n  stability: number\n): number {\n  const { decay, factor } = computeDecayFactor(decayOrParams)\n  return +Math.pow(1 + (factor * elapsed_days) / stability, decay).toFixed(8)\n}\n\n/**\n * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-45\n */\nexport class FSRSAlgorithm {\n  protected param!: FSRSParameters\n  protected intervalModifier!: number\n  protected _seed?: string\n\n  constructor(params: Partial<FSRSParameters>) {\n    this.param = new Proxy(\n      generatorParameters(params),\n      this.params_handler_proxy()\n    )\n    this.intervalModifier = this.calculate_interval_modifier(\n      this.param.request_retention\n    )\n    this.forgetting_curve = forgetting_curve.bind(this, this.param.w)\n  }\n\n  get interval_modifier(): number {\n    return this.intervalModifier\n  }\n\n  set seed(seed: string) {\n    this._seed = seed\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm#fsrs-5\n   *\n   * The formula used is: $$I(r,s) = (r^{\\frac{1}{DECAY}} - 1) / FACTOR \\times s$$\n   * @param request_retention 0<request_retention<=1,Requested retention rate\n   * @throws {Error} Requested retention rate should be in the range (0,1]\n   */\n  calculate_interval_modifier(request_retention: number): number {\n    if (request_retention <= 0 || request_retention > 1) {\n      throw new Error('Requested retention rate should be in the range (0,1]')\n    }\n    const { decay, factor } = computeDecayFactor(this.param.w)\n    return +((Math.pow(request_retention, 1 / decay) - 1) / factor).toFixed(8)\n  }\n\n  /**\n   * Get the parameters of the algorithm.\n   */\n  get parameters(): FSRSParameters {\n    return this.param\n  }\n\n  /**\n   * Set the parameters of the algorithm.\n   * @param params Partial<FSRSParameters>\n   */\n  set parameters(params: Partial<FSRSParameters>) {\n    this.update_parameters(params)\n  }\n\n  protected params_handler_proxy(): ProxyHandler<FSRSParameters> {\n    const _this = this satisfies FSRSAlgorithm\n    return {\n      set: function (\n        target: FSRSParameters,\n        prop: keyof FSRSParameters,\n        value: FSRSParameters[keyof FSRSParameters]\n      ) {\n        if (prop === 'request_retention' && Number.isFinite(value)) {\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(value)\n          )\n        } else if (prop === 'w') {\n          value = migrateParameters(\n            value as FSRSParameters['w'],\n            target.relearning_steps.length,\n            target.enable_short_term\n          )\n          _this.forgetting_curve = forgetting_curve.bind(this, value)\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(target.request_retention)\n          )\n        }\n        Reflect.set(target, prop, value)\n        return true\n      },\n    }\n  }\n\n  private update_parameters(params: Partial<FSRSParameters>): void {\n    const _params = generatorParameters(params)\n    for (const key in _params) {\n      // All keys in _params are guaranteed to exist in this.param due to generatorParameters()\n      const paramKey = key as keyof FSRSParameters\n      this.param[paramKey] = _params[paramKey] as never\n    }\n  }\n\n  /**\n   * The formula used is :\n   * $$ S_0(G) = w_{G-1}$$\n   * $$S_0 = \\max \\lbrace S_0,0.1\\rbrace $$\n\n   * @param g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return Stability (interval when R=90%)\n   */\n  init_stability(g: Grade): number {\n    return Math.max(this.param.w[g - 1], 0.1)\n  }\n\n  /**\n   * The formula used is :\n   * $$D_0(G) = w_4 - e^{(G-1) \\cdot w_5} + 1 $$\n   * $$D_0 = \\min \\lbrace \\max \\lbrace D_0(G),1 \\rbrace,10 \\rbrace$$\n   * where the $$D_0(1)=w_4$$ when the first rating is good.\n   *\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} Difficulty $$D \\in [1,10]$$\n   */\n  init_difficulty(g: Grade): number {\n    const d = this.param.w[4] - Math.exp((g - 1) * this.param.w[5]) + 1\n    return +d.toFixed(8)\n  }\n\n  /**\n   * If fuzzing is disabled or ivl is less than 2.5, it returns the original interval.\n   * @param {number} ivl - The interval to be fuzzed.\n   * @param {number} elapsed_days t days since the last review\n   * @return {number} - The fuzzed interval.\n   **/\n  apply_fuzz(ivl: number, elapsed_days: number): int {\n    if (!this.param.enable_fuzz || ivl < 2.5) return Math.round(ivl) as int\n    const generator = alea(this._seed) // I do not want others to directly access the seed externally.\n    const fuzz_factor = generator()\n    const { min_ivl, max_ivl } = get_fuzz_range(\n      ivl,\n      elapsed_days,\n      this.param.maximum_interval\n    )\n    return Math.floor(fuzz_factor * (max_ivl - min_ivl + 1) + min_ivl) as int\n  }\n\n  /**\n   *   @see The formula used is : {@link FSRSAlgorithm.calculate_interval_modifier}\n   *   @param {number} s - Stability (interval when R=90%)\n   *   @param {number} elapsed_days t days since the last review\n   */\n  next_interval(s: number, elapsed_days: number): int {\n    const newInterval = Math.min(\n      Math.max(1, Math.round(s * this.intervalModifier)),\n      this.param.maximum_interval\n    ) as int\n    return this.apply_fuzz(newInterval, elapsed_days)\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/fsrs4anki/issues/697\n   */\n  linear_damping(delta_d: number, old_d: number): number {\n    return +((delta_d * (10 - old_d)) / 9).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$\\text{delta}_d = -w_6 \\cdot (g - 3)$$\n   * $$\\text{next}_d = D + \\text{linear damping}(\\text{delta}_d , D)$$\n   * $$D^\\prime(D,R) = w_7 \\cdot D_0(4) +(1 - w_7) \\cdot \\text{next}_d$$\n   * @param {number} d Difficulty $$D \\in [1,10]$$\n   * @param {Grade} g Grade (rating at Anki) [1.again,2.hard,3.good,4.easy]\n   * @return {number} $$\\text{next}_D$$\n   */\n  next_difficulty(d: number, g: Grade): number {\n    const delta_d = -this.param.w[6] * (g - 3)\n    const next_d = d + this.linear_damping(delta_d, d)\n    return clamp(\n      this.mean_reversion(this.init_difficulty(Rating.Easy), next_d),\n      1,\n      10\n    )\n  }\n\n  /**\n   * The formula used is :\n   * $$w_7 \\cdot \\text{init} +(1 - w_7) \\cdot \\text{current}$$\n   * @param {number} init $$w_2 : D_0(3) = w_2 + (R-2) \\cdot w_3= w_2$$\n   * @param {number} current $$D - w_6 \\cdot (R - 2)$$\n   * @return {number} difficulty\n   */\n  mean_reversion(init: number, current: number): number {\n    return +(this.param.w[7] * init + (1 - this.param.w[7]) * current).toFixed(\n      8\n    )\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_r(D,S,R,G) = S\\cdot(e^{w_8}\\cdot (11-D)\\cdot S^{-w_9}\\cdot(e^{w_{10}\\cdot(1-R)}-1)\\cdot w_{15}(\\text{if} G=2) \\cdot w_{16}(\\text{if} G=4)+1)$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   * @return {number} S^\\prime_r new stability after recall\n   */\n  next_recall_stability(d: number, s: number, r: number, g: Grade): number {\n    const hard_penalty = Rating.Hard === g ? this.param.w[15] : 1\n    const easy_bound = Rating.Easy === g ? this.param.w[16] : 1\n    return +clamp(\n      s *\n        (1 +\n          Math.exp(this.param.w[8]) *\n            (11 - d) *\n            Math.pow(s, -this.param.w[9]) *\n            (Math.exp((1 - r) * this.param.w[10]) - 1) *\n            hard_penalty *\n            easy_bound),\n      S_MIN,\n      36500.0\n    ).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_f(D,S,R) = w_{11}\\cdot D^{-w_{12}}\\cdot ((S+1)^{w_{13}}-1) \\cdot e^{w_{14}\\cdot(1-R)}$$\n   * enable_short_term = true : $$S^\\prime_f \\in \\min \\lbrace \\max \\lbrace S^\\prime_f,0.01\\rbrace, \\frac{S}{e^{w_{17} \\cdot w_{18}}} \\rbrace$$\n   * enable_short_term = false : $$S^\\prime_f \\in \\min \\lbrace \\max \\lbrace S^\\prime_f,0.01\\rbrace, S \\rbrace$$\n   * @param {number} d Difficulty D \\in [1,10]\n   * @param {number} s Stability (interval when R=90%)\n   * @param {number} r Retrievability (probability of recall)\n   * @return {number} S^\\prime_f new stability after forgetting\n   */\n  next_forget_stability(d: number, s: number, r: number): number {\n    return +clamp(\n      this.param.w[11] *\n        Math.pow(d, -this.param.w[12]) *\n        (Math.pow(s + 1, this.param.w[13]) - 1) *\n        Math.exp((1 - r) * this.param.w[14]),\n      S_MIN,\n      36500.0\n    ).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$S^\\prime_s(S,G) = S \\cdot e^{w_{17} \\cdot (G-3+w_{18})}$$\n   * @param {number} s Stability (interval when R=90%)\n   * @param {Grade} g Grade (Rating[0.again,1.hard,2.good,3.easy])\n   */\n  next_short_term_stability(s: number, g: Grade): number {\n    const sinc =\n      Math.pow(s, -this.param.w[19]) *\n      Math.exp(this.param.w[17] * (g - 3 + this.param.w[18]))\n\n    const maskedSinc = g >= 3 ? Math.max(sinc, 1.0) : sinc\n    return +clamp(s * maskedSinc, S_MIN, 36500.0).toFixed(8)\n  }\n\n  /**\n   * The formula used is :\n   * $$R(t,S) = (1 + \\text{FACTOR} \\times \\frac{t}{9 \\cdot S})^{\\text{DECAY}}$$\n   * @param {number} elapsed_days t days since the last review\n   * @param {number} stability Stability (interval when R=90%)\n   * @return {number} r Retrievability (probability of recall)\n   */\n  forgetting_curve: (elapsed_days: number, stability: number) => number\n  /**\n   * Calculates the next state of memory based on the current state, time elapsed, and grade.\n   *\n   * @param memory_state - The current state of memory, which can be null.\n   * @param t - The time elapsed since the last review.\n   * @param {Rating} g Grade (Rating[0.Manual,1.Again,2.Hard,3.Good,4.Easy])\n   * @returns The next state of memory with updated difficulty and stability.\n   */\n  next_state(memory_state: FSRSState | null, t: number, g: number): FSRSState {\n    const { difficulty: d, stability: s } = memory_state ?? {\n      difficulty: 0,\n      stability: 0,\n    }\n    if (t < 0) {\n      throw new Error(`Invalid delta_t \"${t}\"`)\n    }\n    if (g < 0 || g > 4) {\n      throw new Error(`Invalid grade \"${g}\"`)\n    }\n    if (d === 0 && s === 0) {\n      return {\n        difficulty: clamp(this.init_difficulty(g), 1, 10),\n        stability: this.init_stability(g),\n      }\n    }\n    if (g === 0) {\n      return {\n        difficulty: d,\n        stability: s,\n      }\n    }\n    if (d < 1 || s < S_MIN) {\n      throw new Error(\n        `Invalid memory state { difficulty: ${d}, stability: ${s} }`\n      )\n    }\n    const r = this.forgetting_curve(t, s)\n    const s_after_success = this.next_recall_stability(d, s, r, g)\n    const s_after_fail = this.next_forget_stability(d, s, r)\n    const s_after_short_term = this.next_short_term_stability(s, g)\n    let new_s = s_after_success\n    if (g === 1) {\n      let [w_17, w_18] = [0, 0]\n      if (this.param.enable_short_term) {\n        w_17 = this.param.w[17]\n        w_18 = this.param.w[18]\n      }\n      const next_s_min = s / Math.exp(w_17 * w_18)\n      new_s = clamp(+next_s_min.toFixed(8), S_MIN, s_after_fail)\n    }\n    if (t === 0 && this.param.enable_short_term) {\n      new_s = s_after_short_term\n    }\n\n    const new_d = this.next_difficulty(d, g)\n    return { difficulty: new_d, stability: new_s }\n  }\n}\n", "import { AbstractScheduler } from '../abstract_scheduler'\nimport type { FSRSAlgorithm } from '../algorithm'\nimport { S_MIN } from '../constant'\nimport { TypeConvert } from '../convert'\nimport { clamp, date_scheduler } from '../help'\nimport {\n  type Card,\n  type CardInput,\n  type DateInput,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  State,\n} from '../models'\nimport {\n  StrategyMode,\n  type TLearningStepsStrategy,\n  type TStrategyHandler,\n} from '../strategies'\nimport { BasicLearningStepsStrategy } from '../strategies/learning_steps'\nimport type { int } from '../types'\n\nexport default class BasicScheduler extends AbstractScheduler {\n  private learningStepsStrategy: TLearningStepsStrategy\n\n  constructor(\n    card: CardInput | Card,\n    now: DateInput,\n    algorithm: FSRSAlgorithm,\n    strategies?: Map<StrategyMode, TStrategyHandler>\n  ) {\n    super(card, now, algorithm, strategies)\n\n    // init learning steps strategy\n    let learningStepStrategy = BasicLearningStepsStrategy\n    if (this.strategies) {\n      const custom_strategy = this.strategies.get(StrategyMode.LEARNING_STEPS)\n      if (custom_strategy) {\n        learningStepStrategy = custom_strategy as TLearningStepsStrategy\n      }\n    }\n    this.learningStepsStrategy = learningStepStrategy\n  }\n\n  private getLearningInfo(card: Card, grade: Grade) {\n    const parameters = this.algorithm.parameters\n    card.learning_steps = card.learning_steps || 0\n    const steps_strategy = this.learningStepsStrategy(\n      parameters,\n      card.state,\n      // In the original learning steps setup (Again = 5m, Hard = 10m, Good = FSRS),\n      // not adding 1 can cause slight variations in the memory state’s ds.\n      this.current.state === State.Learning &&\n        grade !== Rating.Again &&\n        grade !== Rating.Hard\n        ? card.learning_steps + 1\n        : card.learning_steps\n    )\n    const scheduled_minutes = Math.max(\n      0,\n      steps_strategy[grade]?.scheduled_minutes ?? 0\n    )\n    const next_steps = Math.max(0, steps_strategy[grade]?.next_step ?? 0)\n    return {\n      scheduled_minutes,\n      next_steps,\n    }\n  }\n  /**\n   * @description This function applies the learning steps based on the current card's state and grade.\n   */\n  private applyLearningSteps(\n    nextCard: Card,\n    grade: Grade,\n    /**\n     * returns the next state for the card (if applicable)\n     */\n    to_state: State\n  ) {\n    const { scheduled_minutes, next_steps } = this.getLearningInfo(\n      this.current,\n      grade\n    )\n    if (\n      scheduled_minutes > 0 &&\n      scheduled_minutes < 1440 /** 1440 minutes = 1 day */\n    ) {\n      nextCard.learning_steps = next_steps\n      nextCard.scheduled_days = 0\n      nextCard.state = to_state\n      nextCard.due = date_scheduler(\n        this.review_time,\n        Math.round(scheduled_minutes) as int,\n        false /** true:days false: minute */\n      )\n    } else {\n      nextCard.state = State.Review\n      if (scheduled_minutes >= 1440) {\n        nextCard.learning_steps = next_steps\n        nextCard.due = date_scheduler(\n          this.review_time,\n          Math.round(scheduled_minutes) as int,\n          false /** true:days false: minute */\n        )\n        nextCard.scheduled_days = Math.floor(scheduled_minutes / 1440)\n      } else {\n        nextCard.learning_steps = 0\n        const interval = this.algorithm.next_interval(\n          nextCard.stability,\n          this.elapsed_days\n        )\n        nextCard.scheduled_days = interval\n        nextCard.due = date_scheduler(this.review_time, interval as int, true)\n      }\n    }\n  }\n\n  protected override newState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const next = TypeConvert.card(this.current)\n    next.difficulty = clamp(this.algorithm.init_difficulty(grade), 1, 10)\n    next.stability = this.algorithm.init_stability(grade)\n\n    this.applyLearningSteps(next, grade, State.Learning)\n    const item = {\n      card: next,\n      log: this.buildLog(grade),\n    } satisfies RecordLogItem\n    this.next.set(grade, item)\n    return item\n  }\n\n  protected override learningState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const { state, difficulty, stability } = this.last\n    const next = TypeConvert.card(this.current)\n    next.difficulty = this.algorithm.next_difficulty(difficulty, grade)\n    next.stability = this.algorithm.next_short_term_stability(stability, grade)\n    this.applyLearningSteps(next, grade, state /** Learning or Relearning */)\n    const item = {\n      card: next,\n      log: this.buildLog(grade),\n    } satisfies RecordLogItem\n    this.next.set(grade, item)\n    return item\n  }\n\n  protected override reviewState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const interval = this.elapsed_days\n    const { difficulty, stability } = this.last\n    const retrievability = this.algorithm.forgetting_curve(interval, stability)\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.next_ds(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      difficulty,\n      stability,\n      retrievability\n    )\n\n    this.next_interval(next_hard, next_good, next_easy, interval)\n    this.next_state(next_hard, next_good, next_easy)\n    this.applyLearningSteps(next_again, Rating.Again, State.Relearning)\n    next_again.lapses += 1\n\n    const item_again = {\n      card: next_again,\n      log: this.buildLog(Rating.Again),\n    } satisfies RecordLogItem\n    const item_hard = {\n      card: next_hard,\n      log: super.buildLog(Rating.Hard),\n    } satisfies RecordLogItem\n    const item_good = {\n      card: next_good,\n      log: super.buildLog(Rating.Good),\n    } satisfies RecordLogItem\n    const item_easy = {\n      card: next_easy,\n      log: super.buildLog(Rating.Easy),\n    } satisfies RecordLogItem\n\n    this.next.set(Rating.Again, item_again)\n    this.next.set(Rating.Hard, item_hard)\n    this.next.set(Rating.Good, item_good)\n    this.next.set(Rating.Easy, item_easy)\n    return this.next.get(grade)!\n  }\n\n  /**\n   * Review next_ds\n   */\n  private next_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    difficulty: number,\n    stability: number,\n    retrievability: number\n  ): void {\n    next_again.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Again\n    )\n    const nextSMin =\n      stability /\n      Math.exp(\n        this.algorithm.parameters.w[17] * this.algorithm.parameters.w[18]\n      )\n    const s_after_fail = this.algorithm.next_forget_stability(\n      difficulty,\n      stability,\n      retrievability\n    )\n    next_again.stability = clamp(+nextSMin.toFixed(8), S_MIN, s_after_fail)\n\n    next_hard.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Hard\n    )\n    next_hard.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Hard\n    )\n    next_good.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Good\n    )\n    next_good.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Good\n    )\n    next_easy.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Easy\n    )\n    next_easy.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Easy\n    )\n  }\n\n  /**\n   * Review next_interval\n   */\n  private next_interval(\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    interval: number\n  ): void {\n    let hard_interval: int, good_interval: int\n    hard_interval = this.algorithm.next_interval(next_hard.stability, interval)\n    good_interval = this.algorithm.next_interval(next_good.stability, interval)\n    hard_interval = Math.min(hard_interval, good_interval) as int\n    good_interval = Math.max(good_interval, hard_interval + 1) as int\n    const easy_interval = Math.max(\n      this.algorithm.next_interval(next_easy.stability, interval),\n      good_interval + 1\n    ) as int\n\n    next_hard.scheduled_days = hard_interval\n    next_hard.due = date_scheduler(this.review_time, hard_interval, true)\n    next_good.scheduled_days = good_interval\n    next_good.due = date_scheduler(this.review_time, good_interval, true)\n\n    next_easy.scheduled_days = easy_interval\n    next_easy.due = date_scheduler(this.review_time, easy_interval, true)\n  }\n\n  /**\n   * Review next_state\n   */\n  private next_state(next_hard: Card, next_good: Card, next_easy: Card) {\n    next_hard.state = State.Review\n    next_hard.learning_steps = 0\n\n    next_good.state = State.Review\n    next_good.learning_steps = 0\n\n    next_easy.state = State.Review\n    next_easy.learning_steps = 0\n  }\n}\n", "import { AbstractScheduler } from '../abstract_scheduler'\nimport { S_MIN } from '../constant'\nimport { TypeConvert } from '../convert'\nimport { clamp, date_scheduler } from '../help'\nimport {\n  type Card,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  State,\n} from '../models'\nimport type { int } from '../types'\n\nexport default class LongTermScheduler extends AbstractScheduler {\n  protected override newState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n\n    this.current.scheduled_days = 0\n    // pending removal in v6.0.0\n    this.current.elapsed_days = 0\n\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.init_ds(next_again, next_hard, next_good, next_easy)\n    const first_interval = 0\n\n    this.next_interval(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      first_interval\n    )\n\n    this.next_state(next_again, next_hard, next_good, next_easy)\n    this.update_next(next_again, next_hard, next_good, next_easy)\n    return this.next.get(grade)!\n  }\n\n  private init_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ): void {\n    next_again.difficulty = clamp(\n      this.algorithm.init_difficulty(Rating.Again),\n      1,\n      10\n    )\n    next_again.stability = this.algorithm.init_stability(Rating.Again)\n\n    next_hard.difficulty = clamp(\n      this.algorithm.init_difficulty(Rating.Hard),\n      1,\n      10\n    )\n    next_hard.stability = this.algorithm.init_stability(Rating.Hard)\n\n    next_good.difficulty = clamp(\n      this.algorithm.init_difficulty(Rating.Good),\n      1,\n      10\n    )\n    next_good.stability = this.algorithm.init_stability(Rating.Good)\n\n    next_easy.difficulty = clamp(\n      this.algorithm.init_difficulty(Rating.Easy),\n      1,\n      10\n    )\n    next_easy.stability = this.algorithm.init_stability(Rating.Easy)\n  }\n\n  /**\n   * @see https://github.com/open-spaced-repetition/ts-fsrs/issues/98#issuecomment-2241923194\n   */\n  protected override learningState(grade: Grade): RecordLogItem {\n    return this.reviewState(grade)\n  }\n  protected override reviewState(grade: Grade): RecordLogItem {\n    const exist = this.next.get(grade)\n    if (exist) {\n      return exist\n    }\n    const interval = this.elapsed_days\n    const { difficulty, stability } = this.last\n    const retrievability = this.algorithm.forgetting_curve(interval, stability)\n    const next_again = TypeConvert.card(this.current)\n    const next_hard = TypeConvert.card(this.current)\n    const next_good = TypeConvert.card(this.current)\n    const next_easy = TypeConvert.card(this.current)\n\n    this.next_ds(\n      next_again,\n      next_hard,\n      next_good,\n      next_easy,\n      difficulty,\n      stability,\n      retrievability\n    )\n\n    this.next_interval(next_again, next_hard, next_good, next_easy, interval)\n    this.next_state(next_again, next_hard, next_good, next_easy)\n    next_again.lapses += 1\n\n    this.update_next(next_again, next_hard, next_good, next_easy)\n    return this.next.get(grade)!\n  }\n\n  /**\n   * Review next_ds\n   */\n  private next_ds(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    difficulty: number,\n    stability: number,\n    retrievability: number\n  ): void {\n    next_again.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Again\n    )\n    const s_after_fail = this.algorithm.next_forget_stability(\n      difficulty,\n      stability,\n      retrievability\n    )\n    next_again.stability = clamp(stability, S_MIN, s_after_fail)\n\n    next_hard.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Hard\n    )\n    next_hard.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Hard\n    )\n    next_good.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Good\n    )\n    next_good.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Good\n    )\n    next_easy.difficulty = this.algorithm.next_difficulty(\n      difficulty,\n      Rating.Easy\n    )\n    next_easy.stability = this.algorithm.next_recall_stability(\n      difficulty,\n      stability,\n      retrievability,\n      Rating.Easy\n    )\n  }\n\n  /**\n   * Review/New next_interval\n   */\n  private next_interval(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card,\n    interval: number\n  ): void {\n    let again_interval: int,\n      hard_interval: int,\n      good_interval: int,\n      easy_interval: int\n    again_interval = this.algorithm.next_interval(\n      next_again.stability,\n      interval\n    )\n    hard_interval = this.algorithm.next_interval(next_hard.stability, interval)\n    good_interval = this.algorithm.next_interval(next_good.stability, interval)\n    easy_interval = this.algorithm.next_interval(next_easy.stability, interval)\n\n    again_interval = Math.min(again_interval, hard_interval) as int\n    hard_interval = Math.max(hard_interval, again_interval + 1) as int\n    good_interval = Math.max(good_interval, hard_interval + 1) as int\n    easy_interval = Math.max(easy_interval, good_interval + 1) as int\n\n    next_again.scheduled_days = again_interval\n    next_again.due = date_scheduler(this.review_time, again_interval, true)\n\n    next_hard.scheduled_days = hard_interval\n    next_hard.due = date_scheduler(this.review_time, hard_interval, true)\n\n    next_good.scheduled_days = good_interval\n    next_good.due = date_scheduler(this.review_time, good_interval, true)\n\n    next_easy.scheduled_days = easy_interval\n    next_easy.due = date_scheduler(this.review_time, easy_interval, true)\n  }\n\n  /**\n   * Review/New next_state\n   */\n  private next_state(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ) {\n    next_again.state = State.Review\n    // next_again.lapses += 1\n    next_again.learning_steps = 0\n\n    next_hard.state = State.Review\n    next_hard.learning_steps = 0\n\n    next_good.state = State.Review\n    next_good.learning_steps = 0\n\n    next_easy.state = State.Review\n    next_easy.learning_steps = 0\n  }\n\n  private update_next(\n    next_again: Card,\n    next_hard: Card,\n    next_good: Card,\n    next_easy: Card\n  ) {\n    const item_again = {\n      card: next_again,\n      log: this.buildLog(Rating.Again),\n    } satisfies RecordLogItem\n    const item_hard = {\n      card: next_hard,\n      log: super.buildLog(Rating.Hard),\n    } satisfies RecordLogItem\n    const item_good = {\n      card: next_good,\n      log: super.buildLog(Rating.Good),\n    } satisfies RecordLogItem\n    const item_easy = {\n      card: next_easy,\n      log: super.buildLog(Rating.Easy),\n    } satisfies RecordLogItem\n\n    this.next.set(Rating.Again, item_again)\n    this.next.set(Rating.Hard, item_hard)\n    this.next.set(Rating.Good, item_good)\n    this.next.set(Rating.Easy, item_easy)\n  }\n}\n", "import { TypeConvert } from './convert'\nimport { createEmptyCard } from './default'\nimport type { FSRS } from './fsrs'\nimport { date_diff } from './help'\nimport {\n  type Card,\n  type CardInput,\n  type DateInput,\n  type FSRSHistory,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  type ReviewLog,\n  State,\n} from './models'\n\n/**\n * The `Reschedule` class provides methods to handle the rescheduling of cards based on their review history.\n * determine the next review dates and update the card's state accordingly.\n */\nexport class Reschedule {\n  private fsrs: FSRS\n  /**\n   * Creates an instance of the `Reschedule` class.\n   * @param fsrs - An instance of the FSRS class used for scheduling.\n   */\n  constructor(fsrs: FSRS) {\n    this.fsrs = fsrs\n  }\n\n  /**\n   * Replays a review for a card and determines the next review date based on the given rating.\n   * @param card - The card being reviewed.\n   * @param reviewed - The date the card was reviewed.\n   * @param rating - The grade given to the card during the review.\n   * @returns A `RecordLogItem` containing the updated card and review log.\n   */\n  replay(card: Card, reviewed: Date, rating: Grade): RecordLogItem {\n    return this.fsrs.next(card, reviewed, rating)\n  }\n\n  /**\n   * Processes a manual review for a card, allowing for custom state, stability, difficulty, and due date.\n   * @param card - The card being reviewed.\n   * @param state - The state of the card after the review.\n   * @param reviewed - The date the card was reviewed.\n   * @param elapsed_days - The number of days since the last review.\n   * @param stability - (Optional) The stability of the card.\n   * @param difficulty - (Optional) The difficulty of the card.\n   * @param due - (Optional) The due date for the next review.\n   * @returns A `RecordLogItem` containing the updated card and review log.\n   * @throws Will throw an error if the state or due date is not provided when required.\n   */\n  handleManualRating(\n    card: Card,\n    state: State,\n    reviewed: Date,\n    elapsed_days: number,\n    stability?: number,\n    difficulty?: number,\n    due?: Date\n  ): RecordLogItem {\n    if (typeof state === 'undefined') {\n      throw new Error('reschedule: state is required for manual rating')\n    }\n    let log: ReviewLog\n    let next_card: Card\n    if (<State>state === State.New) {\n      log = {\n        rating: Rating.Manual,\n        state: state,\n        due: <Date>due ?? reviewed,\n        stability: card.stability,\n        difficulty: card.difficulty,\n        elapsed_days: elapsed_days,\n        last_elapsed_days: card.elapsed_days,\n        scheduled_days: card.scheduled_days,\n        learning_steps: card.learning_steps,\n        review: <Date>reviewed,\n      } satisfies ReviewLog\n      next_card = createEmptyCard<Card>(reviewed)\n      next_card.last_review = reviewed\n    } else {\n      if (typeof due === 'undefined') {\n        throw new Error('reschedule: due is required for manual rating')\n      }\n      const scheduled_days = date_diff(due, reviewed, 'days')\n      log = {\n        rating: Rating.Manual,\n        state: <State>card.state,\n        due: card.last_review || card.due,\n        stability: card.stability,\n        difficulty: card.difficulty,\n        elapsed_days: elapsed_days,\n        last_elapsed_days: card.elapsed_days,\n        scheduled_days: card.scheduled_days,\n        learning_steps: card.learning_steps,\n        review: <Date>reviewed,\n      } satisfies ReviewLog\n      next_card = {\n        ...card,\n        state: <State>state,\n        due: <Date>due,\n        last_review: <Date>reviewed,\n        stability: stability || card.stability,\n        difficulty: difficulty || card.difficulty,\n        elapsed_days: elapsed_days,\n        scheduled_days: scheduled_days,\n        reps: card.reps + 1,\n      } satisfies Card\n    }\n\n    return { card: next_card, log }\n  }\n\n  /**\n   * Reschedules a card based on its review history.\n   *\n   * @param current_card - The card to be rescheduled.\n   * @param reviews - An array of review history objects.\n   * @returns An array of record log items representing the rescheduling process.\n   */\n  reschedule(current_card: CardInput, reviews: FSRSHistory[]) {\n    const collections: RecordLogItem[] = []\n    let cur_card = createEmptyCard<Card>(current_card.due)\n    for (const review of reviews) {\n      let item: RecordLogItem\n      review.review = TypeConvert.time(review.review)\n      if (review.rating === Rating.Manual) {\n        // ref: abstract_scheduler.ts#init\n        let interval = 0\n        if (cur_card.state !== State.New && cur_card.last_review) {\n          interval = date_diff(review.review, cur_card.last_review, 'days')\n        }\n        item = this.handleManualRating(\n          cur_card,\n          review.state,\n          review.review,\n          interval,\n          review.stability,\n          review.difficulty,\n          review.due ? TypeConvert.time(review.due) : undefined\n        )\n      } else {\n        item = this.replay(cur_card, review.review, review.rating)\n      }\n      collections.push(item)\n      cur_card = item.card\n    }\n    return collections\n  }\n\n  calculateManualRecord(\n    current_card: CardInput,\n    now: DateInput,\n    record_log_item?: RecordLogItem,\n    update_memory?: boolean\n  ): RecordLogItem | null {\n    if (!record_log_item) {\n      return null\n    }\n    // if first_card === recordItem.card then return null\n    const { card: reschedule_card, log } = record_log_item\n    const cur_card = <Card>TypeConvert.card(current_card) // copy card\n    if (cur_card.due.getTime() === reschedule_card.due.getTime()) {\n      return null\n    }\n    cur_card.scheduled_days = date_diff(\n      reschedule_card.due,\n      cur_card.due,\n      'days'\n    )\n    return this.handleManualRating(\n      cur_card,\n      reschedule_card.state,\n      TypeConvert.time(now),\n      log.elapsed_days,\n      update_memory ? reschedule_card.stability : undefined,\n      update_memory ? reschedule_card.difficulty : undefined,\n      reschedule_card.due\n    )\n  }\n}\n", "import { FSRSAlgorithm, forgetting_curve } from './algorithm'\nimport { TypeConvert } from './convert'\nimport { createEmptyCard, migrateParameters } from './default'\nimport { date_diff } from './help'\nimport BasicScheduler from './impl/basic_scheduler'\nimport LongTermScheduler from './impl/long_term_scheduler'\nimport {\n  type Card,\n  type CardInput,\n  type DateInput,\n  type FSRSHistory,\n  type FSRSParameters,\n  type Grade,\n  Rating,\n  type RecordLogItem,\n  type ReviewLog,\n  type ReviewLogInput,\n  State,\n} from './models'\nimport { Reschedule } from './reschedule'\nimport {\n  StrategyMode,\n  type TSchedulerStrategy,\n  type TStrategyHandler,\n} from './strategies/types'\nimport type {\n  IPreview,\n  IReschedule,\n  IScheduler,\n  RescheduleOptions,\n} from './types'\n\n// A utility type to require only K properties of A\ntype RequireOnly<A, K extends keyof A> = { [P in K]-?: A[P] } & Partial<\n  Omit<A, K>\n>\n\nexport interface IFSRS {\n  useStrategy<T extends StrategyMode>(\n    mode: T,\n    handler: TStrategyHandler<T>\n  ): this\n\n  clearStrategy(mode?: StrategyMode): this\n\n  repeat(card: CardInput | Card, now: DateInput): IPreview\n  repeat<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler: (recordLog: IPreview) => R\n  ): R\n\n  next(card: CardInput | Card, now: DateInput, grade: Grade): RecordLogItem\n  next<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    grade: Grade,\n    afterHandler: (recordLog: RecordLogItem) => R\n  ): R\n\n  get_retrievability(\n    card: CardInput | Card,\n    now?: DateInput,\n    format?: true\n  ): string\n  get_retrievability(\n    card: CardInput | Card,\n    now?: DateInput,\n    format?: false\n  ): number\n\n  rollback(card: CardInput | Card, log: ReviewLogInput): Card\n  rollback<R>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler: (prevCard: Card) => R\n  ): R\n\n  forget(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count?: boolean\n  ): RecordLogItem\n  forget<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean | undefined,\n    afterHandler: (recordLogItem: RecordLogItem) => R\n  ): R\n\n  reschedule<T = RecordLogItem>(\n    current_card: CardInput | Card,\n    reviews?: FSRSHistory[],\n    options?: RequireOnly<RescheduleOptions<T>, 'recordLogHandler'>\n  ): IReschedule<T>\n  reschedule(\n    current_card: CardInput | Card,\n    reviews?: FSRSHistory[],\n    options?: Partial<RescheduleOptions<RecordLogItem>>\n  ): IReschedule<RecordLogItem>\n}\n\nexport class FSRS extends FSRSAlgorithm implements IFSRS {\n  private strategyHandler = new Map<StrategyMode, TStrategyHandler>()\n  private Scheduler: TSchedulerStrategy\n  constructor(param: Partial<FSRSParameters>) {\n    super(param)\n    const { enable_short_term } = this.parameters\n    this.Scheduler = enable_short_term ? BasicScheduler : LongTermScheduler\n  }\n\n  protected override params_handler_proxy(): ProxyHandler<FSRSParameters> {\n    const _this = this satisfies FSRS\n    return {\n      set: function (\n        target: FSRSParameters,\n        prop: keyof FSRSParameters,\n        value: FSRSParameters[keyof FSRSParameters]\n      ) {\n        if (prop === 'request_retention' && Number.isFinite(value)) {\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(value)\n          )\n        } else if (prop === 'enable_short_term') {\n          _this.Scheduler = value === true ? BasicScheduler : LongTermScheduler\n        } else if (prop === 'w') {\n          value = migrateParameters(\n            value as FSRSParameters['w'],\n            target.relearning_steps.length,\n            target.enable_short_term\n          )\n          _this.forgetting_curve = forgetting_curve.bind(this, value)\n          _this.intervalModifier = _this.calculate_interval_modifier(\n            Number(target.request_retention)\n          )\n        }\n        Reflect.set(target, prop, value)\n        return true\n      },\n    }\n  }\n\n  useStrategy<T extends StrategyMode>(\n    mode: T,\n    handler: TStrategyHandler<T>\n  ): this {\n    this.strategyHandler.set(mode, handler)\n    return this\n  }\n\n  clearStrategy(mode?: StrategyMode): this {\n    if (mode) {\n      this.strategyHandler.delete(mode)\n    } else {\n      this.strategyHandler.clear()\n    }\n    return this\n  }\n\n  private getScheduler(card: CardInput | Card, now: DateInput): IScheduler {\n    // Strategy scheduler\n    const schedulerStrategy = this.strategyHandler.get(\n      StrategyMode.SCHEDULER\n    ) as TSchedulerStrategy | undefined\n\n    const Scheduler = schedulerStrategy || this.Scheduler\n    const instance = new Scheduler(card, now, this, this.strategyHandler)\n\n    return instance\n  }\n\n  repeat(card: CardInput | Card, now: DateInput): IPreview\n  repeat<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler: (recordLog: IPreview) => R\n  ): R\n  /**\n   * Display the collection of cards and logs for the four scenarios after scheduling the card at the current time.\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```typescript\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date());\n   * ```\n   * @example\n   * ```typescript\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n   * function repeatAfterHandler(recordLog: RecordLog) {\n   *     const record: { [key in Grade]: RepeatRecordLog } = {} as {\n   *       [key in Grade]: RepeatRecordLog;\n   *     };\n   *     for (const grade of Grades) {\n   *       record[grade] = {\n   *         card: {\n   *           ...(recordLog[grade].card as Card & { cid: string }),\n   *           due: recordLog[grade].card.due.getTime(),\n   *           state: State[recordLog[grade].card.state] as StateType,\n   *           last_review: recordLog[grade].card.last_review\n   *             ? recordLog[grade].card.last_review!.getTime()\n   *             : null,\n   *         },\n   *         log: {\n   *           ...recordLog[grade].log,\n   *           cid: (recordLog[grade].card as Card & { cid: string }).cid,\n   *           due: recordLog[grade].log.due.getTime(),\n   *           review: recordLog[grade].log.review.getTime(),\n   *           state: State[recordLog[grade].log.state] as StateType,\n   *           rating: Rating[recordLog[grade].log.rating] as RatingType,\n   *         },\n   *       };\n   *     }\n   *     return record;\n   * }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLog = f.repeat(card, new Date(), repeatAfterHandler);\n   * ```\n   */\n  repeat<R = IPreview>(\n    card: CardInput | Card,\n    now: DateInput,\n    afterHandler?: (recordLog: IPreview) => R\n  ): R {\n    const instance = this.getScheduler(card, now)\n    const recordLog = instance.preview()\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLog)\n    } else {\n      return recordLog as R\n    }\n  }\n\n  next(card: CardInput | Card, now: DateInput, grade: Grade): RecordLogItem\n  next<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    grade: Grade,\n    afterHandler: (recordLog: RecordLogItem) => R\n  ): R\n  /**\n   * Display the collection of cards and logs for the card scheduled at the current time, after applying a specific grade rating.\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param grade Rating of the review (Again, Hard, Good, Easy)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```typescript\n   * const card: Card = createEmptyCard(new Date());\n   * const f = fsrs();\n   * const recordLogItem = f.next(card, new Date(), Rating.Again);\n   * ```\n   * @example\n   * ```typescript\n   * interface RevLogUnchecked\n   *   extends Omit<ReviewLog, \"due\" | \"review\" | \"state\" | \"rating\"> {\n   *   cid: string;\n   *   due: Date | number;\n   *   state: StateType;\n   *   review: Date | number;\n   *   rating: RatingType;\n   * }\n   *\n   * interface NextRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked;\n   * }\n   *\n  function nextAfterHandler(recordLogItem: RecordLogItem) {\n    const recordItem = {\n      card: {\n        ...(recordLogItem.card as Card & { cid: string }),\n        due: recordLogItem.card.due.getTime(),\n        state: State[recordLogItem.card.state] as StateType,\n        last_review: recordLogItem.card.last_review\n          ? recordLogItem.card.last_review!.getTime()\n          : null,\n      },\n      log: {\n        ...recordLogItem.log,\n        cid: (recordLogItem.card as Card & { cid: string }).cid,\n        due: recordLogItem.log.due.getTime(),\n        review: recordLogItem.log.review.getTime(),\n        state: State[recordLogItem.log.state] as StateType,\n        rating: Rating[recordLogItem.log.rating] as RatingType,\n      },\n    };\n    return recordItem\n  }\n   * const card: Card = createEmptyCard(new Date(), cardAfterHandler); //see method:  createEmptyCard\n   * const f = fsrs();\n   * const recordLogItem = f.repeat(card, new Date(), Rating.Again, nextAfterHandler);\n   * ```\n   */\n  next<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    grade: Grade,\n    afterHandler?: (recordLog: RecordLogItem) => R\n  ): R {\n    const instance = this.getScheduler(card, now)\n    const g = TypeConvert.rating(grade)\n    if (g === Rating.Manual) {\n      throw new Error('Cannot review a manual rating')\n    }\n    const recordLogItem = instance.review(g)\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLogItem)\n    } else {\n      return recordLogItem as R\n    }\n  }\n\n  get_retrievability(\n    card: CardInput | Card,\n    now?: DateInput,\n    format?: true\n  ): string\n  get_retrievability(\n    card: CardInput | Card,\n    now?: DateInput,\n    format?: false\n  ): number\n  /**\n   * Get the retrievability of the card\n   * @param card  Card to be processed\n   * @param now  Current time or scheduled time\n   * @param format  default:true , Convert the result to another type. (Optional)\n   * @returns  The retrievability of the card,if format is true, the result is a string, otherwise it is a number\n   */\n  get_retrievability(\n    card: CardInput | Card,\n    now?: DateInput,\n    format: boolean = true\n  ): string | number {\n    const processedCard = TypeConvert.card(card)\n    now = now ? TypeConvert.time(now) : new Date()\n    const t =\n      processedCard.state !== State.New\n        ? Math.max(date_diff(now, processedCard.last_review as Date, 'days'), 0)\n        : 0\n    const r =\n      processedCard.state !== State.New\n        ? this.forgetting_curve(t, +processedCard.stability.toFixed(8))\n        : 0\n    return format ? `${(r * 100).toFixed(2)}%` : r\n  }\n\n  rollback(card: CardInput | Card, log: ReviewLogInput): Card\n  rollback<R>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler: (prevCard: Card) => R\n  ): R\n  /**\n   *\n   * @param card Card to be processed\n   * @param log last review log\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```typescript\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now);\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now);\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler);  //see method: createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card, log } = repeatFormAfterHandler[Rating.Hard];\n   * const rollbackFromAfterHandler = f.rollback(card, log, cardAfterHandler);\n   * ```\n   */\n  rollback<R = Card>(\n    card: CardInput | Card,\n    log: ReviewLogInput,\n    afterHandler?: (prevCard: Card) => R\n  ): R {\n    const processedCard = TypeConvert.card(card)\n    const processedLog = TypeConvert.review_log(log)\n    if (processedLog.rating === Rating.Manual) {\n      throw new Error('Cannot rollback a manual rating')\n    }\n    let last_due: Date\n    let last_review: Date | undefined\n    let last_lapses: number\n    switch (processedLog.state) {\n      case State.New:\n        last_due = processedLog.due\n        last_review = undefined\n        last_lapses = 0\n        break\n      case State.Learning:\n      case State.Relearning:\n      case State.Review:\n        last_due = processedLog.review\n        last_review = processedLog.due\n        last_lapses =\n          processedCard.lapses -\n          (processedLog.rating === Rating.Again &&\n          processedLog.state === State.Review\n            ? 1\n            : 0)\n        break\n    }\n\n    const prevCard: Card = {\n      ...processedCard,\n      due: last_due,\n      stability: processedLog.stability,\n      difficulty: processedLog.difficulty,\n      elapsed_days: processedLog.last_elapsed_days,\n      scheduled_days: processedLog.scheduled_days,\n      reps: Math.max(0, processedCard.reps - 1),\n      lapses: Math.max(0, last_lapses),\n      learning_steps: processedLog.learning_steps,\n      state: processedLog.state,\n      last_review: last_review,\n    }\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(prevCard)\n    } else {\n      return prevCard as R\n    }\n  }\n\n  forget(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count?: boolean\n  ): RecordLogItem\n  forget<R>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean | undefined,\n    afterHandler: (recordLogItem: RecordLogItem) => R\n  ): R\n  /**\n   *\n   * @param card Card to be processed\n   * @param now Current time or scheduled time\n   * @param reset_count Should the review count information(reps,lapses) be reset. (Optional)\n   * @param afterHandler Convert the result to another type. (Optional)\n   * @example\n   * ```typescript\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCard = createEmptyCard(now);\n   * const scheduling_cards = f.repeat(emptyCard, now);\n   * const { card, log } = scheduling_cards[Rating.Hard];\n   * const forgetCard = f.forget(card, new Date(), true);\n   * ```\n   *\n   * @example\n   * ```typescript\n   * interface RepeatRecordLog {\n   *   card: CardUnChecked; //see method: createEmptyCard\n   *   log: RevLogUnchecked; //see method: fsrs.repeat()\n   * }\n   *\n   * function forgetAfterHandler(recordLogItem: RecordLogItem): RepeatRecordLog {\n   *     return {\n   *       card: {\n   *         ...(recordLogItem.card as Card & { cid: string }),\n   *         due: recordLogItem.card.due.getTime(),\n   *         state: State[recordLogItem.card.state] as StateType,\n   *         last_review: recordLogItem.card.last_review\n   *           ? recordLogItem.card.last_review!.getTime()\n   *           : null,\n   *       },\n   *       log: {\n   *         ...recordLogItem.log,\n   *         cid: (recordLogItem.card as Card & { cid: string }).cid,\n   *         due: recordLogItem.log.due.getTime(),\n   *         review: recordLogItem.log.review.getTime(),\n   *         state: State[recordLogItem.log.state] as StateType,\n   *         rating: Rating[recordLogItem.log.rating] as RatingType,\n   *       },\n   *     };\n   * }\n   * const now = new Date();\n   * const f = fsrs();\n   * const emptyCardFormAfterHandler = createEmptyCard(now, cardAfterHandler); //see method:  createEmptyCard\n   * const repeatFormAfterHandler = f.repeat(emptyCardFormAfterHandler, now, repeatAfterHandler); //see method: fsrs.repeat()\n   * const { card } = repeatFormAfterHandler[Rating.Hard];\n   * const forgetFromAfterHandler = f.forget(card, date_scheduler(now, 1, true), false, forgetAfterHandler);\n   * ```\n   */\n  forget<R = RecordLogItem>(\n    card: CardInput | Card,\n    now: DateInput,\n    reset_count: boolean = false,\n    afterHandler?: (recordLogItem: RecordLogItem) => R\n  ): R {\n    const processedCard = TypeConvert.card(card)\n    now = TypeConvert.time(now)\n    const scheduled_days =\n      processedCard.state === State.New\n        ? 0\n        : date_diff(now, processedCard.due as Date, 'days')\n    const forget_log: ReviewLog = {\n      rating: Rating.Manual,\n      state: processedCard.state,\n      due: processedCard.due,\n      stability: processedCard.stability,\n      difficulty: processedCard.difficulty,\n      elapsed_days: 0,\n      last_elapsed_days: processedCard.elapsed_days,\n      scheduled_days: scheduled_days,\n      learning_steps: processedCard.learning_steps,\n      review: now,\n    }\n    const forget_card: Card = {\n      ...processedCard,\n      due: now,\n      stability: 0,\n      difficulty: 0,\n      elapsed_days: 0,\n      scheduled_days: 0,\n      reps: reset_count ? 0 : processedCard.reps,\n      lapses: reset_count ? 0 : processedCard.lapses,\n      learning_steps: 0,\n      state: State.New,\n      last_review: processedCard.last_review,\n    }\n    const recordLogItem: RecordLogItem = { card: forget_card, log: forget_log }\n    if (afterHandler && typeof afterHandler === 'function') {\n      return afterHandler(recordLogItem)\n    } else {\n      return recordLogItem as R\n    }\n  }\n\n  reschedule<T = RecordLogItem>(\n    current_card: CardInput | Card,\n    reviews: FSRSHistory[] | undefined,\n    options: RequireOnly<RescheduleOptions<T>, 'recordLogHandler'>\n  ): IReschedule<T>\n  reschedule(\n    current_card: CardInput | Card,\n    reviews?: FSRSHistory[],\n    options?: Partial<RescheduleOptions<RecordLogItem>>\n  ): IReschedule<RecordLogItem>\n  /**\n   * Reschedules the current card and returns the rescheduled collections and reschedule item.\n   *\n   * @template T - The type of the record log item.\n   * @param {CardInput | Card} current_card - The current card to be rescheduled.\n   * @param {Array<FSRSHistory>} reviews - The array of FSRSHistory objects representing the reviews.\n   * @param {Partial<RescheduleOptions<T>>} options - The optional reschedule options.\n   * @returns {IReschedule<T>} - The rescheduled collections and reschedule item.\n   *\n   * @example\n   * ```typescript\n   * const f = fsrs()\n   * const grades: Grade[] = [Rating.Good, Rating.Good, Rating.Good, Rating.Good]\n   * const reviews_at = [\n   *   new Date(2024, 8, 13),\n   *   new Date(2024, 8, 13),\n   *   new Date(2024, 8, 17),\n   *   new Date(2024, 8, 28),\n   * ]\n   *\n   * const reviews: FSRSHistory[] = []\n   * for (let i = 0; i < grades.length; i++) {\n   *   reviews.push({\n   *     rating: grades[i],\n   *     review: reviews_at[i],\n   *   })\n   * }\n   *\n   * const results_short = scheduler.reschedule(\n   *   createEmptyCard(),\n   *   reviews,\n   *   {\n   *     skipManual: false,\n   *   }\n   * )\n   * console.log(results_short)\n   * ```\n   */\n  reschedule<T = RecordLogItem>(\n    current_card: CardInput | Card,\n    reviews: FSRSHistory[] = [],\n    options: Partial<RescheduleOptions<T>> = {}\n  ): IReschedule<T> {\n    const {\n      recordLogHandler,\n      reviewsOrderBy,\n      skipManual = true,\n      now = new Date(),\n      update_memory_state: updateMemoryState = false,\n    } = options\n    if (reviewsOrderBy && typeof reviewsOrderBy === 'function') {\n      reviews.sort(reviewsOrderBy)\n    }\n    if (skipManual) {\n      reviews = reviews.filter((review) => review.rating !== Rating.Manual)\n    }\n    const rescheduleSvc = new Reschedule(this)\n\n    const collections = rescheduleSvc.reschedule(\n      options.first_card || createEmptyCard(),\n      reviews\n    )\n    const len = collections.length\n    const cur_card = TypeConvert.card(current_card)\n    const manual_item = rescheduleSvc.calculateManualRecord(\n      cur_card,\n      now,\n      len ? collections[len - 1] : undefined,\n      updateMemoryState\n    )\n\n    if (recordLogHandler && typeof recordLogHandler === 'function') {\n      return {\n        collections: collections.map(recordLogHandler),\n        reschedule_item: manual_item ? recordLogHandler(manual_item) : null,\n      }\n    }\n    return {\n      collections,\n      reschedule_item: manual_item,\n    } as IReschedule<T>\n  }\n}\n\n/**\n * Create a new instance of TS-FSRS\n * @param params FSRSParameters\n * @example\n * ```typescript\n * const f = fsrs();\n * ```\n * @example\n * ```typescript\n * const params: FSRSParameters = generatorParameters({ maximum_interval: 1000 });\n * const f = fsrs(params);\n * ```\n * @example\n * ```typescript\n * const f = fsrs({ maximum_interval: 1000 });\n * ```\n */\nexport const fsrs = (params?: Partial<FSRSParameters>) => {\n  return new FSRS(params || {})\n}\n"],
  "mappings": "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",
  "names": ["State", "Rating", "StrategyMode", "fsrs"]
}
